%!TEX root = ts.tex
\begin{addedblock}
\rSec0[machine_layer]{Machine Abstraction Layer}

The machine abstraction layer enables a mostly machine-independent implementation of this specification.

\begin{modifcommentblock}
Synopsys is missing.

In what header the following functions are defained?
\end{modifcommentblock}

\rSec1[overflow_detecting_ops]{Overflow-Detecting Operations}

The overflow-detecting functions return a boolean true when the operation overflows, and a boolean false when the operation does not overflow. Compilers may assume that a true result is rare. When the return is false, the function writes the operation result through the given pointer. When the return is true, the pointer is not used and no write occurs.

The following functions are available. Within these prototypes \tcode{T} and \tcode{C} are any integer type. However, \tcode{C} is useful only when it does not have values that \tcode{T} has.

\begin{modifcommentblock}
For the above paragraph:
\begin{itemize}
  \item \tcode{T} and \tcode{C} are too short names. They should be \tcode{Integer}, \tcode{Integer1}, \tcode{Integer2}.
  \item Should those functions be more generic and work with \tcode{wide_integer} and \tcode{integer}? If not, then we can use the concept \tcode{Integral} instead.
\end{itemize}
\end{modifcommentblock}

\begin{modifcommentblock}
Functions below could be used as a basic building block for \tcode{wide_integer}, however they miss a few important things:
\begin{itemize}
  \item \tcode{constexpr} - almost all the operations on \tcode{wide_integer} are \tcode{constexpr}. Without \tcode{constexpr} the below functions are not usable with \tcode{wide_integer}.
  \item \tcode{noexcept} - changing the pointer argument to a reference makes it impossible to pass a \tcode{nullptr} and to get an UB. This is quite helpfull for users and makes the below functions suit better the \tcode{wide_integer} needs.
\end{itemize}
\end{modifcommentblock}

\begin{codeblock}
@\addmodif{\tcode{constexpr }}@bool overflow_neg(T@\tcode{\remmodif{*}\addmodif{\&}}@ result, T value)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@bool overflow_lsh(T@\tcode{\remmodif{*}\addmodif{\&}}@ product, T multiplicand, int count)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@bool overflow_add(T@\tcode{\remmodif{*}\addmodif{\&}}@ summand, T augend, T addend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@bool overflow_sub(T@\tcode{\remmodif{*}\addmodif{\&}}@ difference, T minuend, T subtrahend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@bool overflow_mul(T@\tcode{\remmodif{*}\addmodif{\&}}@ product, T multiplicand, T multiplier)@\addmodif{\tcode{ noexcept}}@;
\end{codeblock}

\rSec1[overflow_handling_ops]{Overflow-Handling Operations}

Overflow-handling operations require an overflow handling mode. We represent the mode in C++ as an enumeration:

\begin{codeblock}
enum class overflow {
	impossible, undefined, abort, exception,
	special,
	saturate, modulo_shifted
};
\end{codeblock}

Within the definition of the following functions, we use a defining function, which we do not expect will be directly represented in C++. It is \tcode{T overflow(mode,T lower,T upper,U value)} where \tcode{U} either
\begin{itemize}
\item has a range that is not a subset of the range of \tcode{T} or
\item is evaluated as a real number expression.
\end{itemize}

Many C++ conversions already reduce the range of a value, but they do not provide programmer control of that reduction. We can give programmers control.

\begin{itemdecl}
template<typename T, typename U> @\addmodif{\tcode{constexpr }}@T convert(overflow mode, U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, numeric_limits<T>::min\addmodif{()}, numeric_limits<T>::max\addmodif{()}, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T, typename U> @\addmodif{\tcode{constexpr }}@T convert(U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{convert(\tcode{\remmodif{m}\addmodif{M}}ode, value)}.	
\end{itemdescr}

Being able to specify overflow from a range of values of the same type is also helpful.

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit(overflow mode, T lower, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, lower, upper, value)}.
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit(T lower, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit(\tcode{\remmodif{m}\addmodif{M}}ode, lower, upper, value)}.
\end{itemdescr}

Common arguments can be elided with convenience functions.

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_nonnegative(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit(mode, 0, upper, value)}.
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit_nonnegative(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_nonnegative(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.
\end{itemdescr}

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_signed(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit(mode, -upper, upper, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> T limit_signed(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_signed(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.	
\end{itemdescr}

Two's-complement numbers are a slight variant on the above.

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_twoscomp(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit(mode, -upper-1, upper, value)}.
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit_twoscomp(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_twoscomp(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.	
\end{itemdescr}

For binary representations, we can also specify bits instead. While this specification may seem redundant, it enables faster implementations.

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_nonnegative_bits(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, 0, $2^{upper}-1$, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit_nonnegative_bits(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_nonnegative_bits(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_signed_bits(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, -($2^{upper}-1$), $2^{upper}-1$, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit_signed_bits(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_signed_bits(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.
\end{itemdescr}

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T limit_twoscomp_bits(overflow mode, T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, $-2^{upper}$, $2^{upper}-1$, value)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T limit_twoscomp_bits(T upper, T value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{limit_twoscomp_bits(\tcode{\remmodif{m}\addmodif{M}}ode, upper, value)}.	
\end{itemdescr}

Embedding overflow detection within regular operations can lead to enhanced performance. In particular, left shift is a important candidate operation within fixed-point arithmetic.

\begin{itemdecl}
template<typename T> @\addmodif{\tcode{constexpr }}@T scale_up(overflow mode, T value, int count)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(mode, numeric_limits<T>::min\addmodif{()}, numeric_limits<T>::max\addmodif{()}, value*$2^{count}$)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> @\addmodif{\tcode{constexpr }}@T scale_up(T value, int count)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{scale_up(\tcode{\remmodif{m}\addmodif{M}}ode, value, count)}.	
\end{itemdescr}

\rSec1[round_ops]{Rounding Operations}

We represent the rounding mode in C++ as an enumeration:

\begin{codeblock}
enum class rounding {
  all_to_neg_inf, all_to_pos_inf,
  all_to_zero, all_away_zero,
  all_to_even, all_to_odd,
  all_fastest, all_smallest,
  all_unspecified,
  tie_to_neg_inf, tie_to_pos_inf,
  tie_to_zero, tie_away_zero,
  tie_to_even, tie_to_odd,
  tie_fastest, tie_smallest,
  tie_unspecified
};
\end{codeblock}

The unmotivated modes \tcode{all_away_zero}, \tcode{all_to_even}, \tcode{all_to_odd}, \tcode{tie_to_neg_inf}, \tcode{tie_to_pos_inf}, and \tcode{tie_to_zero} are conditionally supported.

Within the definition of the following functions, we use a defining function, which we do not expect will be directly represented in C++. It is \tcode{T round(mode,U)} where \tcode{U} either

\begin{itemize}
\item has a finer resolution than \tcode{T} or
\item is evaluated as a real number expression.
\end{itemize}

We already have rounding functions for converting floating-point numbers to integers. However, we need a facility that extends to different sizes of floating-point and between other numeric types.

\begin{itemdecl}
template<typename T, typename U> T convert(rounding mode, U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{round(mode, U)}.	
\end{itemdescr}

\begin{itemdecl}
template<rounding @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T, typename U> T convert(U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{round<T>(\tcode{\remmodif{m}\addmodif{M}}ode, U)}.	
\end{itemdescr}

A division function has obvious utility.

\begin{itemdecl}
template<typename T> T divide(rounding mode, T dividend, T divisor)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{is round(mode, dividend/divisor)}. Remember that division evaluates as a real number. Obviously, the implementation will use a different strategy, but it must yield the same result.	
\end{itemdescr}

\begin{itemdecl}
template<rounding @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> T divide(T dividend, T divisor)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{divide(\tcode{\remmodif{m}\addmodif{M}}ode, dividend, divisor)}.	
\end{itemdescr}

Division by a power of two has substantial implementation efficiencies, and is used heavily in fixed-point arithmetic as a scaling mechanism. We represent the conjunction of these approaches with a rounding scale down (right shift).

\begin{itemdecl}
template<typename T> T scale_down(rounding mode, T value, int bits)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{round(mode, dividend/$2^{bits}$)}.	
\end{itemdescr}

\begin{itemdecl}
template<rounding @\tcode{\remmodif{m}\addmodif{M}}@ode, typename T> T scale_down(T value, int bits)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{scale_down(\tcode{\remmodif{m}\addmodif{M}}ode, dividend, bits)}.	
\end{itemdescr}

\rSec1[combined_rounding]{Combined Rounding and Overflow Operations}

Some operations may reasonably both require rounding and require overflow detection.

First and foremost, conversion from floating-point to integer may require handling a floating-point value that has both a finer resolution and a larger range than the integer can handle. The problem generalizes to arbitrary numeric types.

\begin{itemdecl}
template<typename T, typename U> T convert(overflow omode, rounding rmode, U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{overflow(omode, numeric_limits<T>::min\addmodif{()}, numeric_limits<T>::max\addmodif{()}, round(rmode,value))}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{om}\addmodif{OM}}@ode, rounding @\tcode{\remmodif{rm}\addmodif{RM}}@ode, typename T, typename U> T convert(U value)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{convert(\tcode{\remmodif{om}\addmodif{OM}}ode, \tcode{\remmodif{rm}\addmodif{RM}}ode\tcode{\remmodif{;}\addmodif{,}} value)}.
\end{itemdescr}

Consider shifting as multiplication by a power of two. It has an analogy in a bidirectional shift, where a positive power is a left shift and a negative power is a right shift.

\begin{itemdecl}
template<typename T> T scale(overflow omode, rounding rmode, T value, int count)@\addmodif{;}@
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{count < 0
	? round(rmode,value*$2^{count}$)
	: overflow(omode, numeric_limits<T>::min\addmodif{()}, numeric_limits<T>::max\addmodif{()}, value*$2^{count}$)}.	
\end{itemdescr}

\begin{itemdecl}
template<overflow @\tcode{\remmodif{om}\addmodif{OM}}@ode, rounding @\tcode{\remmodif{rm}\addmodif{RM}}@ode, typename T> T scale(T value, int count)		
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{scale(\tcode{\remmodif{om}\addmodif{OM}}ode, \tcode{\remmodif{rm}\addmodif{RM}}ode\tcode{\addmodif{,}} value\tcode{\addmodif{,}} count)}.	
\end{itemdescr}

\rSec1[double_word_ops]{Double-Word Operations}

There are two classes of functions, those that provide a result in a single double-wide type and those that provide a result split into two single-wide types.

We expect programmers to use type names from \tcode{<cstdint>} or the parametric type aliases (below). Hence, we do not need to provide a means to infer one type size from the other. Within this section, we name these types as follows.

\begin{libreqtab3}
    {Double-word operations}
    {tab:operations}
    \\ \topline
    \lhdr{name} & \rhdr{description} \\ \capsep
    \endfirsthead
    \continuedcaption\\
    \topline
    \lhdr{name} & \rhdr{description} \\ \capsep
    \endhead

S & signed integer type
\\ \rowsep

U & unsigned integer type
\\ \rowsep

DS & signed integer type that is double the width of the S type
\\ \rowsep

DU & unsigned integer type that is double the width of the U type
\\

\end{libreqtab3}  

We need a mechanism to specify the largest supported type for various combinations of function category and operation category. To that end, we propose macros as follows.

\begin{modifcommentblock}
Macros will stop working with modules. Instead of a macro we have to use aliases.

What names should we have for them and do we need to put them into a separate namespace?
\end{modifcommentblock}


\begin{libreqtab3}
    {Macros}
    {tab:macros}
    \\ \topline
    \lhdr{macro name}  &
    \chdr{result category}  &
    \rhdr{operation category} \\ \capsep
    \endfirsthead
    \continuedcaption\\
    \hline
    \lhdr{macro name}  &
    \chdr{result category}  &
    \rhdr{operation category} \\ \capsep
    \endhead
    
LARGEST_DOUBLE_WIDE_ADD & double-wide & add, add2, sub, sub2
\\ \rowsep    

LARGEST_DOUBLE_WIDE_LSH & double-wide & lsh, lshadd
\\ \rowsep

LARGEST_DOUBLE_WIDE_MUL & double-wide & mul, muladd, muladd2, mulsub, mulsub2
\\ \rowsep

LARGEST_DOUBLE_WIDE_DIV & double-wide & divn, divw, divnrem, divwrem
\\ \rowsep

LARGEST_DOUBLE_WIDE_ALL & double-wide & the minimum size of the four macros above
\\ \rowsep

LARGEST_SINGLE_WIDE_ADD & single-wide & add, add2, sub, sub2
\\ \rowsep

LARGEST_SINGLE_WIDE_LSH & single-wide & lsh, lshadd
\\ \rowsep

LARGEST_SINGLE_WIDE_MUL & single-wide & mul, muladd, muladd2, mulsub, mulsub2
\\ \rowsep

LARGEST_SINGLE_WIDE_DIV & single-wide & divn, divw, divnrem, divwrem
\\ \rowsep

LARGEST_SINGLE_WIDE_ALL & double-wide & the minimum size of the four macros above
\\
    
\end{libreqtab3} 

We need a mechanism to build and split double-wide types. The lower part of the split is always an unsigned type.

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@S split_upper(DS value)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@U split_lower(DS value)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DS wide_build(S upper, U lower)@\addmodif{\tcode{ noexcept}}@;

@\addmodif{\tcode{constexpr }}@U split_upper(DU value)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@U split_lower(DU value)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_build(U upper, U lower)@\addmodif{\tcode{ noexcept}}@;
\end{itemdecl}

The arithmetic functions with an double-wide result are as follows. This category seems less important than the next category.

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@DS wide_lsh(S multiplicand, int count);
@\addmodif{\tcode{constexpr }}@DS wide_add(S augend, S addend);
@\addmodif{\tcode{constexpr }}@DS wide_sub(S minuend, S subtrahend);
@\addmodif{\tcode{constexpr }}@DS wide_mul(S multiplicand, S multiplier);
@\addmodif{\tcode{constexpr }}@DS wide_add2(S augend, S addend1, S addend2);
@\addmodif{\tcode{constexpr }}@DS wide_sub2(S minuend, S subtrahend1, S subtrahend2);
@\addmodif{\tcode{constexpr }}@DS wide_lshadd(S multiplicand, int count, S addend);
@\addmodif{\tcode{constexpr }}@DS wide_lshsub(S multiplicand, int count, S subtrahend);
@\addmodif{\tcode{constexpr }}@DS wide_muladd(S multiplicand, S multiplier, S addend);
@\addmodif{\tcode{constexpr }}@DS wide_mulsub(S multiplicand, S multiplier, S subtrahend);
@\addmodif{\tcode{constexpr }}@DS wide_muladd2(S multiplicand, S multiplier, S addend1, S addend2);
@\addmodif{\tcode{constexpr }}@DS wide_mulsub2(S multiplicand, S multiplier, S subtrahend1, S subtrahend2);
@\addmodif{\tcode{constexpr }}@S wide_divn(DS dividend, S divisor);
@\addmodif{\tcode{constexpr }}@DS wide_divw(DS dividend, S divisor);
@\addmodif{\tcode{constexpr }}@S wide_divnrem(S@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, DS dividend, S divisor);
@\addmodif{\tcode{constexpr }}@DS wide_div@\tcode{\remmodif{n}\addmodif{w}}@rem(S@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, DS dividend, S divisor);

@\addmodif{\tcode{constexpr }}@DU wide_lsh(U multiplicand, int count)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_add(U augend, U addend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_sub(U minuend, U subtrahend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_mul(U multiplicand, U multiplier)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_add2(U augend, U addend1, U addend2)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_sub2(U minuend, U subtrahend1, U subtrahend2)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_lshadd(U multiplicand, int count, U addend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_lshsub(U multiplicand, int count, U subtrahend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_muladd(U multiplicand, U multiplier, U addend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_mulsub(U multiplicand, U multiplier, U subtrahend)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_muladd2(U multiplicand, U multiplier, U addend1, U addend2)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@DU wide_mulsub2(U multiplicand, U multiplier, U subtrahend1, U subtrahend2)@\addmodif{\tcode{ noexcept}}@;
@\addmodif{\tcode{constexpr }}@U wide_divn(DU dividend, U divisor);
@\addmodif{\tcode{constexpr }}@DU wide_divw(DU dividend, U divisor);
@\addmodif{\tcode{constexpr }}@U wide_divnrem(U@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, DU dividend, U divisor);
@\addmodif{\tcode{constexpr }}@DU wide_div@\tcode{\remmodif{n}\addmodif{w}}@rem(U@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, DU dividend, U divisor);
\end{itemdecl}

The arithmetic functions with a split result are as follows. The lower part of the result is always an unsigned type. The lower part is returned through a pointer while the upper part is returned as the function result. The intent is that in loops, the lower part is written once to memory while the upper part is carried between iterations in a local variable.


\begin{modifcommentblock}
Do the below functions have wide or narrow contract? Should they be \tcode{noexcept}?
\end{modifcommentblock}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@S split_lsh(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, int count);
@\addmodif{\tcode{constexpr }}@S split_add(U@\tcode{\remmodif{*}\addmodif{\&}}@ summand, S augend, S addend);
@\addmodif{\tcode{constexpr }}@S split_sub(U@\tcode{\remmodif{*}\addmodif{\&}}@ difference, S minuend, S subtrahend);
@\addmodif{\tcode{constexpr }}@S split_mul(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, S multiplier);
@\addmodif{\tcode{constexpr }}@S split_add2(U@\tcode{\remmodif{*}\addmodif{\&}}@ summand, S value1, S addend1, S addend2);
@\addmodif{\tcode{constexpr }}@S split_sub2(U@\tcode{\remmodif{*}\addmodif{\&}}@ difference, S minuend, S subtrahend1, S subtrahend2);
@\addmodif{\tcode{constexpr }}@S split_lshadd(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, int count, S addend);
@\addmodif{\tcode{constexpr }}@S split_lshsub(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, int count, S subtrahend);
@\addmodif{\tcode{constexpr }}@S split_muladd(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, S addend1, S addend);
@\addmodif{\tcode{constexpr }}@S split_mulsub(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, S subtrahend1, S subtrahend2);
@\addmodif{\tcode{constexpr }}@S split_muladd2(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, S multiplier, S addend1, S addend2);
@\addmodif{\tcode{constexpr }}@S split_mulsub2(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, S multiplicand, S multiplier, S subtrahend1, S subtrahend2);
@\addmodif{\tcode{constexpr }}@S split_divn( S dividend_upper, U dividend_lower, S divisor);
@\addmodif{\tcode{constexpr }}@DS split_divw( S dividend_upper, U dividend_lower, S divisor);
@\addmodif{\tcode{constexpr }}@S split_divnrem( S@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, S dividend_upper, U dividend_lower, S divisor);
@\addmodif{\tcode{constexpr }}@DS split_divwrem( S@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, S dividend_upper, U dividend_lower, S divisor);

@\addmodif{\tcode{constexpr }}@U split_lsh(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, int count);
@\addmodif{\tcode{constexpr }}@U split_add(U@\tcode{\remmodif{*}\addmodif{\&}}@ summand, U value1, U addend);
@\addmodif{\tcode{constexpr }}@U split_sub(U@\tcode{\remmodif{*}\addmodif{\&}}@ difference, U minuend, U subtrahend);
@\addmodif{\tcode{constexpr }}@U split_mul(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, U multiplier);
@\addmodif{\tcode{constexpr }}@U split_add2(U@\tcode{\remmodif{*}\addmodif{\&}}@ summand, U value1, U addend1, U addend2);
@\addmodif{\tcode{constexpr }}@U split_sub2(U@\tcode{\remmodif{*}\addmodif{\&}}@ difference, U minuend, U subtrahend1, U subtrahend2);
@\addmodif{\tcode{constexpr }}@U split_lshadd(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, int count, U addend);
@\addmodif{\tcode{constexpr }}@U split_lshsub(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, int count, U subtrahend);
@\addmodif{\tcode{constexpr }}@U split_muladd(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, U multiplier, U addend);
@\addmodif{\tcode{constexpr }}@U split_mulsub(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, U multiplier, U subtrahend);
@\addmodif{\tcode{constexpr }}@U split_muladd2(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, U multiplier, U addend1, U addend2);
@\addmodif{\tcode{constexpr }}@U split_mulsub2(U@\tcode{\remmodif{*}\addmodif{\&}}@ product, U multiplicand, U multiplier, U subtrahend1, U subtrahend2);
@\addmodif{\tcode{constexpr }}@U split_divn(U dividend_upper, U dividend_lower, U divisor);
@\addmodif{\tcode{constexpr }}@DU split_divw(U dividend_upper, U dividend_lower, U divisor);
@\addmodif{\tcode{constexpr }}@U split_divnrem(U@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, U dividend_upper, U dividend_lower, U divisor);
@\addmodif{\tcode{constexpr }}@DU split_divwrem(U@\tcode{\remmodif{*}\addmodif{\&}}@ remainder, U dividend_upper, U dividend_lower, U divisor);
\end{itemdecl}

\rSec0[machine_ext_layer]{Machine extension layer}

The machine extension layer enables the implementation of extended types.

\rSec1[word_array_ops]{Word-array operations}

\begin{modifcommentblock}
C++20 will have a \tcode{std::span} that is designed to be a replacement for \tcode{pointer*} + \tcode{size}. Is provides additional advantages:
\begin{itemize}
  \item bounds may be checked at compile time
  \item compiler could unroll the internal loops knowing the bounds at compile time (an the bounds are known in case of \tcode{wide_integer})
  \item \tcode{std::span} is more simple to use with continious containers and arrays
  \item \tcode{std::span} protects from \tcode{nullptr}
\end{itemize}
Should it be used here?
\end{modifcommentblock}

A word is the type provided by \tcode{LARGEST_SINGLE_WIDE_ALL} and defined above.

We provide the following operations. These operations are not intended to provide complete multi-word operations, but rather to handle subarrays with uniform operations. Higher-level operations then compose these operations into a complete operation.

\begin{modifcommentblock}
\tcode{wide_integer} could benefit from overloads that have an array version of last parameter, like \tcode{U* addend, int addend_length}.
\end{modifcommentblock}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@U unsigned_subarray_addin_word@\tcode{\addmodif{(}}@U* multiplicand, int length, U addend);
\end{itemdecl}

\begin{itemdescr}
\addmodif{\expects \range{multiplicand}{multiplicand + length} is a valid range.}

\effects Add the word \tcode{addend} to the \tcode{multiplicand}\remmodif{ of length \tcode{length}}, leaving the result in the \tcode{multiplicand}.

\returns Any carry out from the accumulator.
\end{itemdescr}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@U unsigned_subarray_add_word@\tcode{\addmodif{(}}@U* summand, const U* augend, int length, U addend);    
\end{itemdecl}

\begin{itemdescr}
\addmodif{\expects \range{multiplicand}{multiplicand + length} is a valid range. \range{augend}{augend + length} is a valid range.}

\effects Add the \tcode{addend} to the \tcode{augend}\remmodif{ of length \tcode{length}} writing the result to the \tcode{summand}, which is also of length \tcode{length}.

\returns Any carry out from the \tcode{summand}.    
\end{itemdescr}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@U unsigned_subarray_mulin_word@\tcode{\addmodif{(}}@U* product, int length, U multiplier);
\end{itemdecl}

\begin{itemdescr}
\addmodif{\expects \range{product}{product + length} is a valid range.}

\effects Multiply the \tcode{product}\remmodif{ of length \tcode{length}} by the \tcode{multiplier}, leaving the result in the \tcode{product}.

\returns Any carry out from the \tcode{product}.
\end{itemdescr}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@U unsigned_subarray_mul_word@\tcode{\addmodif{(}}@U* product, @\tcode{\addmodif{const }}@U* multiplicand, int length, U multiplier);
\end{itemdecl}

\begin{itemdescr}
\addmodif{\expects \range{product}{product + length} is a valid range. \range{multiplicand}{multiplicand + length} is a valid range.}

\effects Multiply the \tcode{multiplicand}\remmodif{ of length \tcode{length}} by the \tcode{multiplier} writing the result to the \tcode{product}\remmodif{, which is also of length \tcode{length}}.

\returns Any carry out from the \tcode{product}.
\end{itemdescr}

\begin{itemdecl}
@\addmodif{\tcode{constexpr }}@U unsigned_subarray_accmul_word@\tcode{\addmodif{(}}@U* accumulator, @\tcode{\addmodif{const }}@U* multiplicand, int length, U multiplier);
\end{itemdecl}

\begin{itemdescr}
\addmodif{\expects \range{accumulator}{accumulator + length} is a valid range. \range{multiplicand}{multiplicand + length} is a valid range.}

\effects Multiply the \tcode{multiplicand}\remmodif{ of length \tcode{length}} by the \tcode{multiplier} adding the result to the \tcode{accumulator}\remmodif{, which is also of length \tcode{length}}.

\returns Any carry out from the \tcode{accumulator}.
\end{itemdescr}

For each of the two add operations above, there is a corresponding subtract operation.

For each of the seven operations above (add+sub+mul), there is a corresponding signed operation. The primary difference between the two is sign extension.

For each of the fourteen operations in above, there is a corresponding operation where the 'right-hand' argument is a pointer to a subarray, which is also of length \tcode{length}.
\end{addedblock}
